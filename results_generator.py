"""
Results generator module for Jegadeesh & Titman (1993) momentum strategy replication.
Generates tables matching the original paper's format and additional analysis tables.
"""

import pandas as pd
import numpy as np
import logging
from typing import Dict, List, Tuple, Optional
from pathlib import Path
import warnings

import config
from momentum_strategy import MomentumStrategy
from utils import format_percentage, format_number, ensure_directory_exists

# Set up logging
logging.basicConfig(level=getattr(logging, config.LOGGING_LEVEL))
logger = logging.getLogger(__name__)

class ResultsGenerator:
    """
    Class for generating results tables in the format of Jegadeesh & Titman (1993).
    Creates publication-ready tables with proper formatting and statistical tests.
    """
    
    def __init__(self, strategy: MomentumStrategy):
        """
        Initialize ResultsGenerator.
        
        Parameters:
        -----------
        strategy : MomentumStrategy
            Completed momentum strategy analysis
        """
        self.strategy = strategy
        self.tables = {}
    
    def generate_all_tables(self) -> Dict[str, pd.DataFrame]:
        """
        Generate all results tables.\n        
        Returns:\n        --------\n        Dict[str, pd.DataFrame]\n            Dictionary of generated tables\n        \"\"\"\n        logger.info(\"Generating all results tables...\")\n        \n        tables = {}\n        \n        # Table I: Average Monthly Returns by (J,K) Strategy\n        tables['table_i_monthly_returns'] = self.generate_monthly_returns_table()\n        \n        # Table II: Winner-Loser Spreads with Statistical Tests\n        tables['winner_loser_spreads'] = self.generate_winner_loser_spreads_table()\n        \n        # Table III: Portfolio Performance Summary\n        tables['portfolio_performance'] = self.generate_portfolio_performance_table()\n        \n        # Table IV: Risk-Adjusted Returns (if market data available)\n        if self.strategy.market_data is not None and not self.strategy.market_data.empty:\n            tables['risk_adjusted_returns'] = self.generate_risk_adjusted_returns_table()\n        \n        # Additional Analysis Tables\n        tables['momentum_statistics'] = self.generate_momentum_statistics_table()\n        tables['portfolio_characteristics'] = self.generate_portfolio_characteristics_table()\n        \n        self.tables = tables\n        logger.info(f\"Generated {len(tables)} results tables\")\n        \n        return tables\n    \n    def generate_monthly_returns_table(self) -> pd.DataFrame:\n        \"\"\"\n        Generate Table I: Average Monthly Returns by Formation and Holding Periods.\n        Replicates the main results table from Jegadeesh & Titman (1993).\n        \n        Returns:\n        --------\n        pd.DataFrame\n            Monthly returns table\n        \"\"\"\n        logger.info(\"Generating monthly returns table (Table I)...\")\n        \n        # Create results matrix\n        results_data = []\n        \n        for j in self.strategy.formation_periods:\n            for k in self.strategy.holding_periods:\n                if (j, k) in self.strategy.strategy_returns:\n                    returns_data = self.strategy.strategy_returns[(j, k)]\n                    \n                    if not returns_data.empty:\n                        # Calculate returns for each portfolio\n                        portfolio_returns = {}\n                        \n                        for portfolio_num in sorted(returns_data['portfolio_num'].unique()):\n                            portfolio_data = returns_data[\n                                returns_data['portfolio_num'] == portfolio_num\n                            ]\n                            \n                            if not portfolio_data.empty:\n                                mean_return = portfolio_data['portfolio_return'].mean() * 100  # Convert to percentage\n                                std_error = portfolio_data['portfolio_return'].std() / np.sqrt(len(portfolio_data))\n                                t_stat = portfolio_data['portfolio_return'].mean() / std_error if std_error > 0 else np.nan\n                                \n                                portfolio_returns[f'P{portfolio_num}'] = {\n                                    'return': mean_return,\n                                    't_stat': t_stat,\n                                    'observations': len(portfolio_data)\n                                }\n                        \n                        # Calculate winner-loser spread\n                        if f'P{self.strategy.num_portfolios}' in portfolio_returns and 'P1' in portfolio_returns:\n                            winner_ret = portfolio_returns[f'P{self.strategy.num_portfolios}']['return']\n                            loser_ret = portfolio_returns['P1']['return']\n                            spread = winner_ret - loser_ret\n                            \n                            # Calculate spread t-statistic\n                            winner_data = returns_data[returns_data['portfolio_num'] == self.strategy.num_portfolios]['portfolio_return']\n                            loser_data = returns_data[returns_data['portfolio_num'] == 1]['portfolio_return']\n                            \n                            if len(winner_data) > 0 and len(loser_data) > 0:\n                                spread_series = winner_data.values - loser_data.values[:len(winner_data)]\n                                spread_std = np.std(spread_series, ddof=1) if len(spread_series) > 1 else np.nan\n                                spread_t_stat = np.mean(spread_series) / (spread_std / np.sqrt(len(spread_series))) if spread_std > 0 else np.nan\n                            else:\n                                spread_t_stat = np.nan\n                        else:\n                            spread = np.nan\n                            spread_t_stat = np.nan\n                        \n                        # Add row to results\n                        row = {\n                            'Formation (J)': j,\n                            'Holding (K)': k,\n                            'Winner-Loser Spread (%)': spread,\n                            'Spread t-stat': spread_t_stat\n                        }\n                        \n                        # Add individual portfolio returns\n                        for portfolio_num in range(1, self.strategy.num_portfolios + 1):\n                            if f'P{portfolio_num}' in portfolio_returns:\n                                row[f'Portfolio {portfolio_num} (%)'] = portfolio_returns[f'P{portfolio_num}']['return']\n                                row[f'P{portfolio_num} t-stat'] = portfolio_returns[f'P{portfolio_num}']['t_stat']\n                        \n                        results_data.append(row)\n        \n        return pd.DataFrame(results_data)\n    \n    def generate_winner_loser_spreads_table(self) -> pd.DataFrame:\n        \"\"\"\n        Generate winner-loser spreads table with statistical significance.\n        \n        Returns:\n        --------\n        pd.DataFrame\n            Winner-loser spreads table\n        \"\"\"\n        logger.info(\"Generating winner-loser spreads table...\")\n        \n        spreads_data = []\n        \n        for j in self.strategy.formation_periods:\n            for k in self.strategy.holding_periods:\n                if (j, k) in self.strategy.strategy_returns:\n                    returns_data = self.strategy.strategy_returns[(j, k)]\n                    \n                    if not returns_data.empty:\n                        # Get winner and loser returns\n                        winner_returns = returns_data[\n                            returns_data['portfolio_num'] == self.strategy.num_portfolios\n                        ]['portfolio_return']\n                        \n                        loser_returns = returns_data[\n                            returns_data['portfolio_num'] == 1\n                        ]['portfolio_return']\n                        \n                        if len(winner_returns) > 0 and len(loser_returns) > 0:\n                            # Calculate spread statistics\n                            min_length = min(len(winner_returns), len(loser_returns))\n                            spread_returns = winner_returns.iloc[:min_length].values - loser_returns.iloc[:min_length].values\n                            \n                            mean_spread = np.mean(spread_returns) * 100  # Convert to percentage\n                            std_spread = np.std(spread_returns, ddof=1)\n                            t_stat = np.mean(spread_returns) / (std_spread / np.sqrt(len(spread_returns))) if std_spread > 0 else np.nan\n                            \n                            # Determine significance\n                            significance = \"\"\n                            if abs(t_stat) > 2.576:  # 1% level\n                                significance = \"***\"\n                            elif abs(t_stat) > 1.96:  # 5% level\n                                significance = \"**\"\n                            elif abs(t_stat) > 1.645:  # 10% level\n                                significance = \"*\"\n                            \n                            spreads_data.append({\n                                'Formation': j,\n                                'Holding': k,\n                                'Mean Return (%)': mean_spread,\n                                'Std Error (%)': std_spread * 100,\n                                't-statistic': t_stat,\n                                'Significance': significance,\n                                'Observations': len(spread_returns),\n                                'Annualized Return (%)': mean_spread * 12\n                            })\n        \n        df = pd.DataFrame(spreads_data)\n        \n        # Sort by formation then holding period\n        if not df.empty:\n            df = df.sort_values(['Formation', 'Holding']).reset_index(drop=True)\n        \n        return df\n    \n    def generate_portfolio_performance_table(self) -> pd.DataFrame:\n        \"\"\"\n        Generate comprehensive portfolio performance table.\n        \n        Returns:\n        --------\n        pd.DataFrame\n            Portfolio performance table\n        \"\"\"\n        logger.info(\"Generating portfolio performance table...\")\n        \n        performance_data = []\n        \n        for (j, k), returns_data in self.strategy.strategy_returns.items():\n            if not returns_data.empty:\n                # Calculate performance metrics\n                performance_metrics = self.strategy.returns_calculator.calculate_performance_metrics(\n                    returns_data, self.strategy.market_data\n                )\n                \n                # Add metrics for each portfolio\n                for portfolio_key, metrics in performance_metrics.items():\n                    if 'portfolio_' in portfolio_key:\n                        portfolio_num = int(portfolio_key.split('_')[1])\n                        \n                        row = {\n                            'Formation (J)': j,\n                            'Holding (K)': k,\n                            'Portfolio': portfolio_num,\n                            'Mean Return (%)': metrics.get('mean_return', np.nan) * 100,\n                            'Std Dev (%)': metrics.get('std_return', np.nan) * 100,\n                            'Sharpe Ratio': metrics.get('sharpe_ratio', np.nan),\n                            'Annualized Return (%)': metrics.get('annualized_return', np.nan) * 100,\n                            'Annualized Vol (%)': metrics.get('annualized_volatility', np.nan) * 100,\n                            'Max Drawdown (%)': metrics.get('max_drawdown', np.nan) * 100,\n                            'Observations': metrics.get('observations', 0)\n                        }\n                        \n                        # Add risk-adjusted metrics if available\n                        if 'alpha_annualized' in metrics:\n                            row['Alpha (%)'] = metrics['alpha_annualized'] * 100\n                            row['Beta'] = metrics.get('beta', np.nan)\n                            row['Alpha t-stat'] = metrics.get('alpha_t_stat', np.nan)\n                        \n                        performance_data.append(row)\n                \n                # Add long-short portfolio\n                if 'long_short' in performance_metrics:\n                    ls_metrics = performance_metrics['long_short']\n                    \n                    row = {\n                        'Formation (J)': j,\n                        'Holding (K)': k,\n                        'Portfolio': 'Long-Short',\n                        'Mean Return (%)': ls_metrics.get('mean_return', np.nan) * 100,\n                        'Std Dev (%)': ls_metrics.get('std_return', np.nan) * 100,\n                        'Sharpe Ratio': ls_metrics.get('sharpe_ratio', np.nan),\n                        'Annualized Return (%)': ls_metrics.get('annualized_return', np.nan) * 100,\n                        'Annualized Vol (%)': ls_metrics.get('annualized_volatility', np.nan) * 100,\n                        'Max Drawdown (%)': np.nan,\n                        'Observations': ls_metrics.get('observations', 0)\n                    }\n                    \n                    performance_data.append(row)\n        \n        return pd.DataFrame(performance_data)\n    \n    def generate_risk_adjusted_returns_table(self) -> pd.DataFrame:\n        \"\"\"\n        Generate risk-adjusted returns table (CAPM alphas and betas).\n        \n        Returns:\n        --------\n        pd.DataFrame\n            Risk-adjusted returns table\n        \"\"\"\n        logger.info(\"Generating risk-adjusted returns table...\")\n        \n        risk_adjusted_data = []\n        \n        for (j, k), returns_data in self.strategy.strategy_returns.items():\n            if not returns_data.empty:\n                performance_metrics = self.strategy.returns_calculator.calculate_performance_metrics(\n                    returns_data, self.strategy.market_data\n                )\n                \n                # Focus on long-short portfolio for risk adjustment\n                if 'long_short' in performance_metrics:\n                    # Need to calculate CAPM metrics for long-short portfolio\n                    ls_returns_data = self.strategy.returns_calculator.calculate_long_short_returns(returns_data)\n                    \n                    if not ls_returns_data.empty and self.strategy.market_data is not None:\n                        # Merge with market data for CAPM analysis\n                        merged = pd.merge(\n                            ls_returns_data[['date', 'long_short_return']],\n                            self.strategy.market_data[['date', 'market_ret', 'rf_rate']],\n                            on='date',\n                            how='inner'\n                        )\n                        \n                        if not merged.empty and len(merged) >= 10:\n                            # Calculate excess returns\n                            merged['excess_return'] = merged['long_short_return'] - merged['rf_rate']\n                            merged['market_excess'] = merged['market_ret'] - merged['rf_rate']\n                            \n                            # CAPM regression\n                            X = merged['market_excess'].values\n                            y = merged['excess_return'].values\n                            \n                            # Remove NaN values\n                            valid_mask = ~(np.isnan(X) | np.isnan(y))\n                            X_clean = X[valid_mask]\n                            y_clean = y[valid_mask]\n                            \n                            if len(X_clean) >= 10:\n                                # Calculate beta and alpha\n                                beta = np.cov(X_clean, y_clean)[0, 1] / np.var(X_clean) if np.var(X_clean) > 0 else np.nan\n                                alpha = np.mean(y_clean) - beta * np.mean(X_clean)\n                                \n                                # Calculate alpha standard error and t-statistic\n                                y_pred = alpha + beta * X_clean\n                                residuals = y_clean - y_pred\n                                alpha_std_error = np.std(residuals, ddof=2) / np.sqrt(len(X_clean))\n                                alpha_t_stat = alpha / alpha_std_error if alpha_std_error > 0 else np.nan\n                                \n                                # Calculate R-squared\n                                ss_res = np.sum(residuals ** 2)\n                                ss_tot = np.sum((y_clean - np.mean(y_clean)) ** 2)\n                                r_squared = 1 - (ss_res / ss_tot) if ss_tot > 0 else 0\n                                \n                                risk_adjusted_data.append({\n                                    'Formation (J)': j,\n                                    'Holding (K)': k,\n                                    'Alpha (% monthly)': alpha * 100,\n                                    'Alpha (% annualized)': alpha * 12 * 100,\n                                    'Alpha t-stat': alpha_t_stat,\n                                    'Beta': beta,\n                                    'R-squared': r_squared,\n                                    'Observations': len(X_clean)\n                                })\n        \n        return pd.DataFrame(risk_adjusted_data)\n    \n    def generate_momentum_statistics_table(self) -> pd.DataFrame:\n        \"\"\"\n        Generate momentum score statistics table.\n        \n        Returns:\n        --------\n        pd.DataFrame\n            Momentum statistics table\n        \"\"\"\n        logger.info(\"Generating momentum statistics table...\")\n        \n        momentum_stats = []\n        \n        for j, momentum_data in self.strategy.momentum_scores.items():\n            if not momentum_data.empty:\n                stats = self.strategy.momentum_calculator.get_momentum_summary_statistics(momentum_data)\n                \n                row = {\n                    'Formation Period (months)': j,\n                    'Observations': stats.get('count', 0),\n                    'Mean Momentum (%)': stats.get('mean', np.nan) * 100,\n                    'Median Momentum (%)': stats.get('median', np.nan) * 100,\n                    'Std Dev (%)': stats.get('std', np.nan) * 100,\n                    'Skewness': stats.get('skewness', np.nan),\n                    'Kurtosis': stats.get('kurtosis', np.nan),\n                    'Positive Momentum (%)': stats.get('positive_momentum_pct', np.nan)\n                }\n                \n                momentum_stats.append(row)\n        \n        return pd.DataFrame(momentum_stats)\n    \n    def generate_portfolio_characteristics_table(self) -> pd.DataFrame:\n        \"\"\"\n        Generate portfolio characteristics table.\n        \n        Returns:\n        --------\n        pd.DataFrame\n            Portfolio characteristics table\n        \"\"\"\n        logger.info(\"Generating portfolio characteristics table...\")\n        \n        characteristics_data = []\n        \n        for (j, k), portfolio_data in self.strategy.portfolios.items():\n            if not portfolio_data.empty:\n                stats = self.strategy.portfolio_builder.get_portfolio_statistics(j, k)\n                \n                row = {\n                    'Formation (J)': j,\n                    'Holding (K)': k,\n                    'Total Observations': stats.get('total_observations', 0),\n                    'Unique Stocks': stats.get('unique_stocks', 0),\n                    'Formation Dates': stats.get('formation_dates', 0),\n                    'Avg Stocks per Portfolio': stats.get('portfolio_1_stocks_per_period', np.nan),\n                    'Winner Avg Momentum (%)': stats.get('winner_avg_momentum', np.nan) * 100,\n                    'Loser Avg Momentum (%)': stats.get('loser_avg_momentum', np.nan) * 100,\n                    'Momentum Spread (%)': stats.get('momentum_spread', np.nan) * 100\n                }\n                \n                characteristics_data.append(row)\n        \n        return pd.DataFrame(characteristics_data)\n    \n    def save_tables(self, tables: Dict[str, pd.DataFrame], \n                   output_dir: str = config.RESULTS_DIR,\n                   format: str = 'csv') -> None:\n        \"\"\"\n        Save all tables to files.\n        \n        Parameters:\n        -----------\n        tables : Dict[str, pd.DataFrame]\n            Tables to save\n        output_dir : str\n            Output directory\n        format : str\n            Output format ('csv', 'excel', 'latex')\n        \"\"\"\n        ensure_directory_exists(output_dir)\n        \n        for table_name, table_df in tables.items():\n            if not table_df.empty:\n                filename = f\"{table_name}.{format}\"\n                filepath = Path(output_dir) / filename\n                \n                if format == 'csv':\n                    table_df.to_csv(filepath, index=False, float_format='%.4f')\n                elif format == 'excel':\n                    table_df.to_excel(filepath, index=False, float_format='%.4f')\n                elif format == 'latex':\n                    latex_str = table_df.to_latex(index=False, float_format='%.4f')\n                    with open(filepath, 'w') as f:\n                        f.write(latex_str)\n                \n                logger.info(f\"Saved {table_name} to {filepath}\")\n    \n    def format_table_for_publication(self, table: pd.DataFrame, \n                                   decimal_places: int = 2) -> pd.DataFrame:\n        \"\"\"\n        Format table for publication with proper number formatting.\n        \n        Parameters:\n        -----------\n        table : pd.DataFrame\n            Table to format\n        decimal_places : int\n            Number of decimal places\n            \n        Returns:\n        --------\n        pd.DataFrame\n            Formatted table\n        \"\"\"\n        formatted_table = table.copy()\n        \n        # Format numeric columns\n        for col in formatted_table.columns:\n            if formatted_table[col].dtype in ['float64', 'int64']:\n                if 'stat' in col.lower() or 'ratio' in col.lower():\n                    # Special formatting for statistics\n                    formatted_table[col] = formatted_table[col].apply(\n                        lambda x: f\"{x:.3f}\" if not pd.isna(x) else \"\"\n                    )\n                elif '%' in col:\n                    # Percentage columns\n                    formatted_table[col] = formatted_table[col].apply(\n                        lambda x: f\"{x:.{decimal_places}f}\" if not pd.isna(x) else \"\"\n                    )\n                else:\n                    # Other numeric columns\n                    formatted_table[col] = formatted_table[col].apply(\n                        lambda x: f\"{x:.{decimal_places}f}\" if not pd.isna(x) else \"\"\n                    )\n        \n        return formatted_table\n\ndef main():\n    \"\"\"\n    Example usage of ResultsGenerator.\n    \"\"\"\n    # This would typically be called from main.py\n    # See main.py for complete usage example\n    pass\n\nif __name__ == \"__main__\":\n    main()