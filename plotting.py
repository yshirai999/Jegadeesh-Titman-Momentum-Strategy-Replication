"""
Plotting module for Jegadeesh & Titman (1993) momentum strategy replication.
Creates visualizations and charts for momentum strategy analysis.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from typing import Dict, List, Tuple, Optional
import warnings
from pathlib import Path

import config
from momentum_strategy import MomentumStrategy
from utils import ensure_directory_exists

# Set up plotting style
plt.style.use('default')
sns.set_palette("husl")
warnings.filterwarnings('ignore', category=FutureWarning)

class MomentumPlotter:
    """
    Class for creating visualizations of momentum strategy results.
    Generates publication-quality plots and charts.
    """
    
    def __init__(self, strategy: MomentumStrategy):
        """
        Initialize MomentumPlotter.
        
        Parameters:
        -----------
        strategy : MomentumStrategy
            Completed momentum strategy analysis
        """
        self.strategy = strategy
        self.figures_created = 0
    
    def create_all_plots(self, 
                        output_dir: str = config.FIGURES_DIR,\n                        format: str = 'png',\n                        dpi: int = 300) -> int:\n        \"\"\"\n        Create all momentum strategy plots.\n        \n        Parameters:\n        -----------\n        output_dir : str\n            Output directory for figures\n        format : str\n            Figure format ('png', 'pdf', 'svg')\n        dpi : int\n            Figure resolution\n            \n        Returns:\n        --------\n        int\n            Number of figures created\n        \"\"\"\n        ensure_directory_exists(output_dir)\n        \n        # Set figure parameters\n        plt.rcParams['figure.dpi'] = dpi\n        plt.rcParams['savefig.dpi'] = dpi\n        plt.rcParams['savefig.format'] = format\n        \n        self.figures_created = 0\n        \n        # 1. Winner-Loser Spreads Heatmap\n        self.plot_winner_loser_heatmap(output_dir, format)\n        \n        # 2. Cumulative Returns Plot\n        self.plot_cumulative_returns(output_dir, format)\n        \n        # 3. Monthly Returns Distribution\n        self.plot_returns_distribution(output_dir, format)\n        \n        # 4. Portfolio Performance Comparison\n        self.plot_portfolio_performance(output_dir, format)\n        \n        # 5. Momentum Score Distribution\n        self.plot_momentum_distributions(output_dir, format)\n        \n        # 6. Risk-Return Scatter\n        self.plot_risk_return_scatter(output_dir, format)\n        \n        # 7. Rolling Performance\n        self.plot_rolling_performance(output_dir, format)\n        \n        # 8. Drawdown Analysis\n        self.plot_drawdown_analysis(output_dir, format)\n        \n        return self.figures_created\n    \n    def plot_winner_loser_heatmap(self, output_dir: str, format: str) -> None:\n        \"\"\"\n        Create heatmap of winner-loser spreads by formation and holding periods.\n        \"\"\"\n        try:\n            # Get winner-loser spreads\n            spreads_data = []\n            \n            for j in self.strategy.formation_periods:\n                for k in self.strategy.holding_periods:\n                    if (j, k) in self.strategy.strategy_returns:\n                        returns_data = self.strategy.strategy_returns[(j, k)]\n                        \n                        if not returns_data.empty:\n                            winner_returns = returns_data[\n                                returns_data['portfolio_num'] == self.strategy.num_portfolios\n                            ]['portfolio_return']\n                            \n                            loser_returns = returns_data[\n                                returns_data['portfolio_num'] == 1\n                            ]['portfolio_return']\n                            \n                            if len(winner_returns) > 0 and len(loser_returns) > 0:\n                                min_length = min(len(winner_returns), len(loser_returns))\n                                spread = (winner_returns.iloc[:min_length].values - \n                                        loser_returns.iloc[:min_length].values).mean() * 100\n                                \n                                spreads_data.append({\n                                    'Formation': j,\n                                    'Holding': k,\n                                    'Spread': spread\n                                })\n            \n            if spreads_data:\n                spreads_df = pd.DataFrame(spreads_data)\n                \n                # Create pivot table for heatmap\n                heatmap_data = spreads_df.pivot(index='Formation', columns='Holding', values='Spread')\n                \n                # Create heatmap\n                fig, ax = plt.subplots(figsize=(10, 8))\n                \n                sns.heatmap(heatmap_data, \n                           annot=True, \n                           fmt='.2f', \n                           cmap='RdYlGn',\n                           center=0,\n                           cbar_kws={'label': 'Monthly Return (%)'},\n                           ax=ax)\n                \n                ax.set_title('Winner-Loser Portfolio Spreads\\nby Formation and Holding Periods', \n                            fontsize=14, fontweight='bold')\n                ax.set_xlabel('Holding Period (K months)', fontsize=12)\n                ax.set_ylabel('Formation Period (J months)', fontsize=12)\n                \n                plt.tight_layout()\n                self._save_figure(fig, 'winner_loser_heatmap', output_dir, format)\n        \n        except Exception as e:\n            print(f\"Warning: Could not create winner-loser heatmap: {e}\")\n    \n    def plot_cumulative_returns(self, output_dir: str, format: str) -> None:\n        \"\"\"\n        Plot cumulative returns for selected momentum strategies.\n        \"\"\"\n        try:\n            # Select a few representative strategies\n            selected_strategies = [(6, 6), (12, 12), (3, 3)] if len(self.strategy.strategy_returns) >= 3 else list(self.strategy.strategy_returns.keys())[:3]\n            \n            fig, axes = plt.subplots(2, 2, figsize=(15, 12))\n            axes = axes.flatten()\n            \n            for idx, (j, k) in enumerate(selected_strategies):\n                if (j, k) in self.strategy.strategy_returns:\n                    returns_data = self.strategy.strategy_returns[(j, k)]\n                    \n                    if not returns_data.empty:\n                        ax = axes[idx]\n                        \n                        # Plot cumulative returns for each portfolio\n                        for portfolio_num in sorted(returns_data['portfolio_num'].unique()):\n                            portfolio_data = returns_data[\n                                returns_data['portfolio_num'] == portfolio_num\n                            ].sort_values('date')\n                            \n                            if not portfolio_data.empty:\n                                cumulative_returns = (1 + portfolio_data['portfolio_return']).cumprod()\n                                \n                                label = f'P{portfolio_num}'\n                                if portfolio_num == 1:\n                                    label = 'Loser'\n                                elif portfolio_num == self.strategy.num_portfolios:\n                                    label = 'Winner'\n                                \n                                ax.plot(portfolio_data['date'], cumulative_returns, \n                                       label=label, linewidth=2 if portfolio_num in [1, self.strategy.num_portfolios] else 1,\n                                       alpha=0.8 if portfolio_num in [1, self.strategy.num_portfolios] else 0.6)\n                        \n                        ax.set_title(f'Cumulative Returns: ({j},{k}) Strategy', fontweight='bold')\n                        ax.set_xlabel('Date')\n                        ax.set_ylabel('Cumulative Return')\n                        ax.legend()\n                        ax.grid(True, alpha=0.3)\n            \n            # Hide unused subplot\n            if len(selected_strategies) < 4:\n                axes[3].set_visible(False)\n            \n            plt.tight_layout()\n            self._save_figure(fig, 'cumulative_returns', output_dir, format)\n        \n        except Exception as e:\n            print(f\"Warning: Could not create cumulative returns plot: {e}\")\n    \n    def plot_returns_distribution(self, output_dir: str, format: str) -> None:\n        \"\"\"\n        Plot distribution of monthly returns for winner and loser portfolios.\n        \"\"\"\n        try:\n            # Combine data from all strategies\n            all_winner_returns = []\n            all_loser_returns = []\n            \n            for (j, k), returns_data in self.strategy.strategy_returns.items():\n                if not returns_data.empty:\n                    winner_returns = returns_data[\n                        returns_data['portfolio_num'] == self.strategy.num_portfolios\n                    ]['portfolio_return'] * 100\n                    \n                    loser_returns = returns_data[\n                        returns_data['portfolio_num'] == 1\n                    ]['portfolio_return'] * 100\n                    \n                    all_winner_returns.extend(winner_returns.tolist())\n                    all_loser_returns.extend(loser_returns.tolist())\n            \n            if all_winner_returns and all_loser_returns:\n                fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))\n                \n                # Histogram\n                ax1.hist(all_loser_returns, bins=30, alpha=0.7, label='Loser Portfolios', color='red')\n                ax1.hist(all_winner_returns, bins=30, alpha=0.7, label='Winner Portfolios', color='green')\n                ax1.set_xlabel('Monthly Return (%)')\n                ax1.set_ylabel('Frequency')\n                ax1.set_title('Distribution of Monthly Returns', fontweight='bold')\n                ax1.legend()\n                ax1.grid(True, alpha=0.3)\n                \n                # Box plot\n                data_to_plot = [all_loser_returns, all_winner_returns]\n                labels = ['Loser', 'Winner']\n                \n                box_plot = ax2.boxplot(data_to_plot, labels=labels, patch_artist=True)\n                box_plot['boxes'][0].set_facecolor('red')\n                box_plot['boxes'][1].set_facecolor('green')\n                \n                ax2.set_ylabel('Monthly Return (%)')\n                ax2.set_title('Return Distribution Comparison', fontweight='bold')\n                ax2.grid(True, alpha=0.3)\n                \n                plt.tight_layout()\n                self._save_figure(fig, 'returns_distribution', output_dir, format)\n        \n        except Exception as e:\n            print(f\"Warning: Could not create returns distribution plot: {e}\")\n    \n    def plot_portfolio_performance(self, output_dir: str, format: str) -> None:\n        \"\"\"\n        Plot portfolio performance metrics comparison.\n        \"\"\"\n        try:\n            # Collect performance data\n            performance_data = []\n            \n            for (j, k), returns_data in list(self.strategy.strategy_returns.items())[:6]:  # Limit to 6 strategies\n                if not returns_data.empty:\n                    performance_metrics = self.strategy.returns_calculator.calculate_performance_metrics(returns_data)\n                    \n                    if 'long_short' in performance_metrics:\n                        ls_metrics = performance_metrics['long_short']\n                        \n                        performance_data.append({\n                            'Strategy': f'({j},{k})',\n                            'Annual Return (%)': ls_metrics.get('annualized_return', np.nan) * 100,\n                            'Annual Vol (%)': ls_metrics.get('annualized_volatility', np.nan) * 100,\n                            'Sharpe Ratio': ls_metrics.get('sharpe_ratio', np.nan),\n                            'Monthly Return (%)': ls_metrics.get('mean_return', np.nan) * 100\n                        })\n            \n            if performance_data:\n                df = pd.DataFrame(performance_data)\n                \n                fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 12))\n                \n                # Annual Return\n                ax1.bar(df['Strategy'], df['Annual Return (%)'], color='steelblue', alpha=0.7)\n                ax1.set_title('Annualized Returns by Strategy', fontweight='bold')\n                ax1.set_ylabel('Annual Return (%)')\n                ax1.tick_params(axis='x', rotation=45)\n                ax1.grid(True, alpha=0.3)\n                \n                # Volatility\n                ax2.bar(df['Strategy'], df['Annual Vol (%)'], color='orange', alpha=0.7)\n                ax2.set_title('Annualized Volatility by Strategy', fontweight='bold')\n                ax2.set_ylabel('Annual Volatility (%)')\n                ax2.tick_params(axis='x', rotation=45)\n                ax2.grid(True, alpha=0.3)\n                \n                # Sharpe Ratio\n                ax3.bar(df['Strategy'], df['Sharpe Ratio'], color='green', alpha=0.7)\n                ax3.set_title('Sharpe Ratios by Strategy', fontweight='bold')\n                ax3.set_ylabel('Sharpe Ratio')\n                ax3.tick_params(axis='x', rotation=45)\n                ax3.grid(True, alpha=0.3)\n                \n                # Risk-Return Scatter\n                ax4.scatter(df['Annual Vol (%)'], df['Annual Return (%)'], \n                           s=100, alpha=0.7, c='purple')\n                \n                for i, strategy in enumerate(df['Strategy']):\n                    ax4.annotate(strategy, \n                                (df.iloc[i]['Annual Vol (%)'], df.iloc[i]['Annual Return (%)']),\n                                xytext=(5, 5), textcoords='offset points', fontsize=9)\n                \n                ax4.set_xlabel('Annual Volatility (%)')\n                ax4.set_ylabel('Annual Return (%)')\n                ax4.set_title('Risk-Return Profile', fontweight='bold')\n                ax4.grid(True, alpha=0.3)\n                \n                plt.tight_layout()\n                self._save_figure(fig, 'portfolio_performance', output_dir, format)\n        \n        except Exception as e:\n            print(f\"Warning: Could not create portfolio performance plot: {e}\")\n    \n    def plot_momentum_distributions(self, output_dir: str, format: str) -> None:\n        \"\"\"\n        Plot momentum score distributions by formation period.\n        \"\"\"\n        try:\n            n_periods = len(self.strategy.momentum_scores)\n            \n            if n_periods == 0:\n                return\n            \n            fig, axes = plt.subplots(2, 2, figsize=(15, 12))\n            axes = axes.flatten()\n            \n            for idx, (j, momentum_data) in enumerate(list(self.strategy.momentum_scores.items())[:4]):\n                if not momentum_data.empty and idx < 4:\n                    ax = axes[idx]\n                    \n                    momentum_scores = momentum_data['momentum_score'] * 100  # Convert to percentage\n                    \n                    # Histogram\n                    ax.hist(momentum_scores, bins=50, alpha=0.7, color='skyblue', edgecolor='black')\n                    \n                    # Add vertical lines for percentiles\n                    percentiles = [10, 25, 50, 75, 90]\n                    colors = ['red', 'orange', 'green', 'orange', 'red']\n                    \n                    for pct, color in zip(percentiles, colors):\n                        value = np.percentile(momentum_scores, pct)\n                        ax.axvline(value, color=color, linestyle='--', alpha=0.8, \n                                  label=f'{pct}th percentile')\n                    \n                    ax.set_title(f'{j}-Month Formation Period\\nMomentum Score Distribution', fontweight='bold')\n                    ax.set_xlabel('Momentum Score (%)')\n                    ax.set_ylabel('Frequency')\n                    ax.grid(True, alpha=0.3)\n                    \n                    if idx == 0:  # Only show legend on first subplot\n                        ax.legend()\n            \n            # Hide unused subplots\n            for idx in range(n_periods, 4):\n                axes[idx].set_visible(False)\n            \n            plt.tight_layout()\n            self._save_figure(fig, 'momentum_distributions', output_dir, format)\n        \n        except Exception as e:\n            print(f\"Warning: Could not create momentum distributions plot: {e}\")\n    \n    def plot_risk_return_scatter(self, output_dir: str, format: str) -> None:\n        \"\"\"\n        Create risk-return scatter plot for all strategies.\n        \"\"\"\n        try:\n            risk_return_data = []\n            \n            for (j, k), returns_data in self.strategy.strategy_returns.items():\n                if not returns_data.empty:\n                    performance_metrics = self.strategy.returns_calculator.calculate_performance_metrics(returns_data)\n                    \n                    if 'long_short' in performance_metrics:\n                        ls_metrics = performance_metrics['long_short']\n                        \n                        risk_return_data.append({\n                            'Strategy': f'({j},{k})',\n                            'Return': ls_metrics.get('annualized_return', np.nan) * 100,\n                            'Risk': ls_metrics.get('annualized_volatility', np.nan) * 100,\n                            'Sharpe': ls_metrics.get('sharpe_ratio', np.nan),\n                            'J': j,\n                            'K': k\n                        })\n            \n            if risk_return_data:\n                df = pd.DataFrame(risk_return_data)\n                \n                fig, ax = plt.subplots(figsize=(12, 8))\n                \n                # Color by Sharpe ratio\n                scatter = ax.scatter(df['Risk'], df['Return'], \n                                   c=df['Sharpe'], s=100, \n                                   cmap='viridis', alpha=0.7)\n                \n                # Add colorbar\n                cbar = plt.colorbar(scatter)\n                cbar.set_label('Sharpe Ratio', rotation=270, labelpad=15)\n                \n                # Annotate points\n                for i, row in df.iterrows():\n                    ax.annotate(row['Strategy'], \n                               (row['Risk'], row['Return']),\n                               xytext=(5, 5), textcoords='offset points', fontsize=9)\n                \n                ax.set_xlabel('Annualized Volatility (%)', fontsize=12)\n                ax.set_ylabel('Annualized Return (%)', fontsize=12)\n                ax.set_title('Risk-Return Profile of Momentum Strategies', fontsize=14, fontweight='bold')\n                ax.grid(True, alpha=0.3)\n                \n                plt.tight_layout()\n                self._save_figure(fig, 'risk_return_scatter', output_dir, format)\n        \n        except Exception as e:\n            print(f\"Warning: Could not create risk-return scatter plot: {e}\")\n    \n    def plot_rolling_performance(self, output_dir: str, format: str) -> None:\n        \"\"\"\n        Plot rolling performance metrics.\n        \"\"\"\n        try:\n            # Select one representative strategy\n            if not self.strategy.strategy_returns:\n                return\n            \n            representative_strategy = list(self.strategy.strategy_returns.keys())[0]\n            returns_data = self.strategy.strategy_returns[representative_strategy]\n            \n            if returns_data.empty:\n                return\n            \n            # Calculate long-short returns\n            ls_returns = self.strategy.returns_calculator.calculate_long_short_returns(returns_data)\n            \n            if ls_returns.empty:\n                return\n            \n            ls_returns = ls_returns.sort_values('date')\n            \n            # Calculate rolling metrics (12-month window)\n            window = 12\n            ls_returns['rolling_return'] = ls_returns['long_short_return'].rolling(window).mean() * 100\n            ls_returns['rolling_volatility'] = ls_returns['long_short_return'].rolling(window).std() * 100\n            ls_returns['rolling_sharpe'] = (ls_returns['long_short_return'].rolling(window).mean() / \n                                           ls_returns['long_short_return'].rolling(window).std()) * np.sqrt(12)\n            \n            fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(15, 12))\n            \n            # Rolling return\n            ax1.plot(ls_returns['date'], ls_returns['rolling_return'], linewidth=2, color='blue')\n            ax1.axhline(y=0, color='black', linestyle='--', alpha=0.5)\n            ax1.set_title(f'12-Month Rolling Performance: {representative_strategy} Strategy', fontweight='bold')\n            ax1.set_ylabel('Rolling Return (%)')\n            ax1.grid(True, alpha=0.3)\n            \n            # Rolling volatility\n            ax2.plot(ls_returns['date'], ls_returns['rolling_volatility'], linewidth=2, color='red')\n            ax2.set_ylabel('Rolling Volatility (%)')\n            ax2.grid(True, alpha=0.3)\n            \n            # Rolling Sharpe ratio\n            ax3.plot(ls_returns['date'], ls_returns['rolling_sharpe'], linewidth=2, color='green')\n            ax3.axhline(y=0, color='black', linestyle='--', alpha=0.5)\n            ax3.set_xlabel('Date')\n            ax3.set_ylabel('Rolling Sharpe Ratio')\n            ax3.grid(True, alpha=0.3)\n            \n            plt.tight_layout()\n            self._save_figure(fig, 'rolling_performance', output_dir, format)\n        \n        except Exception as e:\n            print(f\"Warning: Could not create rolling performance plot: {e}\")\n    \n    def plot_drawdown_analysis(self, output_dir: str, format: str) -> None:\n        \"\"\"\n        Plot drawdown analysis for momentum strategies.\n        \"\"\"\n        try:\n            # Select representative strategies\n            selected_strategies = list(self.strategy.strategy_returns.keys())[:3]\n            \n            fig, axes = plt.subplots(len(selected_strategies), 1, figsize=(15, 4*len(selected_strategies)))\n            \n            if len(selected_strategies) == 1:\n                axes = [axes]\n            \n            for idx, (j, k) in enumerate(selected_strategies):\n                returns_data = self.strategy.strategy_returns[(j, k)]\n                \n                if not returns_data.empty:\n                    # Calculate long-short returns\n                    ls_returns = self.strategy.returns_calculator.calculate_long_short_returns(returns_data)\n                    \n                    if not ls_returns.empty:\n                        ls_returns = ls_returns.sort_values('date')\n                        \n                        # Calculate cumulative returns and drawdowns\n                        cumulative_returns = (1 + ls_returns['long_short_return']).cumprod()\n                        running_max = cumulative_returns.expanding().max()\n                        drawdowns = (cumulative_returns - running_max) / running_max\n                        \n                        ax = axes[idx]\n                        \n                        # Plot cumulative returns\n                        ax2 = ax.twinx()\n                        \n                        ax.fill_between(ls_returns['date'], drawdowns * 100, 0, \n                                       alpha=0.3, color='red', label='Drawdown')\n                        ax2.plot(ls_returns['date'], cumulative_returns, \n                                linewidth=2, color='blue', label='Cumulative Return')\n                        \n                        ax.set_ylabel('Drawdown (%)', color='red')\n                        ax2.set_ylabel('Cumulative Return', color='blue')\n                        ax.set_title(f'Drawdown Analysis: ({j},{k}) Strategy', fontweight='bold')\n                        \n                        ax.grid(True, alpha=0.3)\n                        \n                        # Add legend\n                        lines1, labels1 = ax.get_legend_handles_labels()\n                        lines2, labels2 = ax2.get_legend_handles_labels()\n                        ax.legend(lines1 + lines2, labels1 + labels2, loc='upper left')\n            \n            plt.tight_layout()\n            self._save_figure(fig, 'drawdown_analysis', output_dir, format)\n        \n        except Exception as e:\n            print(f\"Warning: Could not create drawdown analysis plot: {e}\")\n    \n    def _save_figure(self, fig, name: str, output_dir: str, format: str) -> None:\n        \"\"\"\n        Save figure to file.\n        \n        Parameters:\n        -----------\n        fig : matplotlib.figure.Figure\n            Figure to save\n        name : str\n            Figure name\n        output_dir : str\n            Output directory\n        format : str\n            Figure format\n        \"\"\"\n        try:\n            filepath = Path(output_dir) / f\"{name}.{format}\"\n            fig.savefig(filepath, dpi=300, bbox_inches='tight', facecolor='white')\n            plt.close(fig)\n            self.figures_created += 1\n        except Exception as e:\n            print(f\"Warning: Could not save figure {name}: {e}\")\n            plt.close(fig)\n\ndef main():\n    \"\"\"\n    Example usage of MomentumPlotter.\n    \"\"\"\n    # This would typically be called from main.py\n    # See main.py for complete usage example\n    pass\n\nif __name__ == \"__main__\":\n    main()