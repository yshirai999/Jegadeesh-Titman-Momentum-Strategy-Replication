"""
Returns calculator module for Jegadeesh & Titman (1993) momentum strategy replication.
Calculates portfolio and strategy returns with proper handling of overlapping portfolios.
"""

import pandas as pd
import numpy as np
import logging
from typing import Dict, List, Tuple, Optional, Union
from datetime import datetime
import warnings

import config
from utils import calculate_portfolio_return, calculate_compound_return, calculate_annualized_return, calculate_volatility

# Set up logging
logging.basicConfig(level=getattr(logging, config.LOGGING_LEVEL))
logger = logging.getLogger(__name__)

class ReturnsCalculator:
    """
    Class for calculating portfolio and strategy returns in momentum strategies.
    Handles overlapping portfolios and various return metrics.
    """
    
    def __init__(self):
        """Initialize ReturnsCalculator."""
        self.return_data = {}
    
    def calculate_portfolio_returns(self, 
                                  overlapping_portfolios: pd.DataFrame,
                                  stock_data: pd.DataFrame,
                                  j: int, k: int) -> pd.DataFrame:
        """
        Calculate returns for overlapping momentum portfolios.
        
        Parameters:
        -----------
        overlapping_portfolios : pd.DataFrame
            Overlapping portfolio holdings by date
        stock_data : pd.DataFrame
            Stock return data
        j : int
            Formation period
        k : int
            Holding period
            
        Returns:
        --------
        pd.DataFrame
            Portfolio returns by date and portfolio number
        """
        logger.info(f"Calculating portfolio returns for ({j},{k}) strategy...")\n        
        stock_id = self._get_stock_id_column(stock_data)\n        
        # Get unique dates and portfolio numbers\n        dates = sorted(overlapping_portfolios['date'].unique())\n        portfolio_numbers = sorted(overlapping_portfolios['portfolio_num'].unique())\n        \n        return_results = []\n        \n        for date in dates:\n            # Get stock returns for this date\n            date_returns = stock_data[stock_data['date'] == date]\n            \n            if date_returns.empty:\n                continue\n            \n            # Calculate returns for each portfolio\n            for portfolio_num in portfolio_numbers:\n                portfolio_holdings = overlapping_portfolios[\n                    (overlapping_portfolios['date'] == date) &\n                    (overlapping_portfolios['portfolio_num'] == portfolio_num)\n                ]\n                \n                if portfolio_holdings.empty:\n                    continue\n                \n                # Calculate weighted portfolio return\n                portfolio_return = self._calculate_weighted_return(\n                    portfolio_holdings, date_returns, stock_id\n                )\n                \n                if not np.isnan(portfolio_return):\n                    return_results.append({\n                        'date': date,\n                        'portfolio_num': portfolio_num,\n                        'portfolio_return': portfolio_return,\n                        'num_stocks': len(portfolio_holdings),\n                        'formation_period': j,\n                        'holding_period': k\n                    })\n        \n        result_df = pd.DataFrame(return_results)\n        \n        if not result_df.empty:\n            logger.info(f"Calculated returns for {len(result_df)} portfolio-date observations")\n        \n        return result_df\n    \n    def _calculate_weighted_return(self, \n                                 portfolio_holdings: pd.DataFrame,\n                                 stock_returns: pd.DataFrame,\n                                 stock_id: str) -> float:\n        """\n        Calculate weighted return for a portfolio on a specific date.\n        \n        Parameters:\n        -----------\n        portfolio_holdings : pd.DataFrame\n            Portfolio holdings with weights\n        stock_returns : pd.DataFrame\n            Stock returns for the date\n        stock_id : str\n            Stock identifier column\n            \n        Returns:\n        --------\n        float\n            Weighted portfolio return\n        """\n        # Merge holdings with returns\n        merged = pd.merge(\n            portfolio_holdings[[stock_id, 'adjusted_weight']],\n            stock_returns[[stock_id, 'ret']],\n            on=stock_id,\n            how='inner'\n        )\n        \n        if merged.empty:\n            return np.nan\n        \n        # Remove missing returns\n        merged = merged.dropna(subset=['ret', 'adjusted_weight'])\n        \n        if merged.empty or merged['adjusted_weight'].sum() == 0:\n            return np.nan\n        \n        # Renormalize weights for available returns\n        total_weight = merged['adjusted_weight'].sum()\n        normalized_weights = merged['adjusted_weight'] / total_weight\n        \n        # Calculate weighted return\n        portfolio_return = (normalized_weights * merged['ret']).sum()\n        \n        return portfolio_return\n    \n    def calculate_long_short_returns(self, \n                                   portfolio_returns: pd.DataFrame) -> pd.DataFrame:\n        """\n        Calculate long-short (winner minus loser) portfolio returns.\n        \n        Parameters:\n        -----------\n        portfolio_returns : pd.DataFrame\n            Portfolio returns by date and portfolio number\n            \n        Returns:\n        --------\n        pd.DataFrame\n            Long-short strategy returns\n        """\n        if portfolio_returns.empty:\n            return pd.DataFrame()\n        \n        # Get winner (highest portfolio number) and loser (portfolio 1) returns\n        max_portfolio = portfolio_returns['portfolio_num'].max()\n        \n        winner_returns = portfolio_returns[\n            portfolio_returns['portfolio_num'] == max_portfolio\n        ][['date', 'portfolio_return', 'formation_period', 'holding_period']].copy()\n        winner_returns.columns = ['date', 'winner_return', 'formation_period', 'holding_period']\n        \n        loser_returns = portfolio_returns[\n            portfolio_returns['portfolio_num'] == 1\n        ][['date', 'portfolio_return']].copy()\n        loser_returns.columns = ['date', 'loser_return']\n        \n        # Merge winner and loser returns\n        long_short = pd.merge(winner_returns, loser_returns, on='date', how='inner')\n        \n        if not long_short.empty:\n            long_short['long_short_return'] = long_short['winner_return'] - long_short['loser_return']\n        \n        return long_short\n    \n    def calculate_cumulative_returns(self, \n                                   portfolio_returns: pd.DataFrame) -> pd.DataFrame:\n        """\n        Calculate cumulative returns for portfolios.\n        \n        Parameters:\n        -----------\n        portfolio_returns : pd.DataFrame\n            Portfolio returns by date\n            \n        Returns:\n        --------\n        pd.DataFrame\n            Cumulative returns\n        """\n        if portfolio_returns.empty:\n            return pd.DataFrame()\n        \n        cumulative_data = []\n        \n        for portfolio_num in portfolio_returns['portfolio_num'].unique():\n            portfolio_data = portfolio_returns[\n                portfolio_returns['portfolio_num'] == portfolio_num\n            ].sort_values('date')\n            \n            if not portfolio_data.empty:\n                # Calculate cumulative returns\n                portfolio_data = portfolio_data.copy()\n                portfolio_data['cumulative_return'] = (1 + portfolio_data['portfolio_return']).cumprod() - 1\n                cumulative_data.append(portfolio_data)\n        \n        if cumulative_data:\n            return pd.concat(cumulative_data, ignore_index=True)\n        else:\n            return pd.DataFrame()\n    \n    def calculate_performance_metrics(self, \n                                    portfolio_returns: pd.DataFrame,\n                                    market_data: Optional[pd.DataFrame] = None) -> Dict:\n        """\n        Calculate comprehensive performance metrics for portfolios.\n        \n        Parameters:\n        -----------\n        portfolio_returns : pd.DataFrame\n            Portfolio returns by date and portfolio\n        market_data : pd.DataFrame, optional\n            Market and risk-free rate data\n            \n        Returns:\n        --------\n        Dict\n            Performance metrics by portfolio\n        """\n        if portfolio_returns.empty:\n            return {}\n        \n        metrics = {}\n        \n        for portfolio_num in portfolio_returns['portfolio_num'].unique():\n            portfolio_data = portfolio_returns[\n                portfolio_returns['portfolio_num'] == portfolio_num\n            ].sort_values('date')\n            \n            if len(portfolio_data) < 2:\n                continue\n            \n            returns = portfolio_data['portfolio_return'].values\n            \n            # Basic return metrics\n            portfolio_metrics = {\n                'mean_return': np.mean(returns),\n                'median_return': np.median(returns),\n                'std_return': np.std(returns, ddof=1),\n                'min_return': np.min(returns),\n                'max_return': np.max(returns),\n                'skewness': self._calculate_skewness(returns),\n                'kurtosis': self._calculate_kurtosis(returns),\n                'observations': len(returns)\n            }\n            \n            # Annualized metrics\n            portfolio_metrics['annualized_return'] = calculate_annualized_return(returns, 'monthly')\n            portfolio_metrics['annualized_volatility'] = calculate_volatility(returns, 'monthly', True)\n            \n            # Risk metrics\n            if portfolio_metrics['annualized_volatility'] > 0:\n                portfolio_metrics['sharpe_ratio'] = (\n                    portfolio_metrics['annualized_return'] / portfolio_metrics['annualized_volatility']\n                )\n            else:\n                portfolio_metrics['sharpe_ratio'] = np.nan\n            \n            # Drawdown metrics\n            cumulative_returns = (1 + pd.Series(returns)).cumprod()\n            portfolio_metrics.update(self._calculate_drawdown_metrics(cumulative_returns))\n            \n            # Market-adjusted metrics (if market data available)\n            if market_data is not None:\n                market_metrics = self._calculate_market_adjusted_metrics(\n                    portfolio_data, market_data\n                )\n                portfolio_metrics.update(market_metrics)\n            \n            metrics[f'portfolio_{portfolio_num}'] = portfolio_metrics\n        \n        # Long-short portfolio metrics\n        long_short_returns = self.calculate_long_short_returns(portfolio_returns)\n        if not long_short_returns.empty:\n            ls_returns = long_short_returns['long_short_return'].values\n            \n            ls_metrics = {\n                'mean_return': np.mean(ls_returns),\n                'std_return': np.std(ls_returns, ddof=1),\n                'annualized_return': calculate_annualized_return(ls_returns, 'monthly'),\n                'annualized_volatility': calculate_volatility(ls_returns, 'monthly', True),\n                't_statistic': np.mean(ls_returns) / (np.std(ls_returns, ddof=1) / np.sqrt(len(ls_returns))),\n                'observations': len(ls_returns)\n            }\n            \n            if ls_metrics['annualized_volatility'] > 0:\n                ls_metrics['sharpe_ratio'] = (\n                    ls_metrics['annualized_return'] / ls_metrics['annualized_volatility']\n                )\n            \n            metrics['long_short'] = ls_metrics\n        \n        return metrics\n    \n    def _calculate_market_adjusted_metrics(self, \n                                         portfolio_data: pd.DataFrame,\n                                         market_data: pd.DataFrame) -> Dict:\n        """\n        Calculate market-adjusted performance metrics.\n        \n        Parameters:\n        -----------\n        portfolio_data : pd.DataFrame\n            Portfolio return data\n        market_data : pd.DataFrame\n            Market and risk-free rate data\n            \n        Returns:\n        --------\n        Dict\n            Market-adjusted metrics\n        """\n        # Merge portfolio and market data\n        merged = pd.merge(\n            portfolio_data[['date', 'portfolio_return']],\n            market_data[['date', 'market_ret', 'rf_rate']],\n            on='date',\n            how='inner'\n        )\n        \n        if merged.empty or len(merged) < 10:\n            return {}\n        \n        # Calculate excess returns\n        merged['excess_return'] = merged['portfolio_return'] - merged['rf_rate']\n        merged['market_excess'] = merged['market_ret'] - merged['rf_rate']\n        \n        metrics = {}\n        \n        # CAPM metrics\n        try:\n            # Simple linear regression: excess_return = alpha + beta * market_excess\n            X = merged['market_excess'].values\n            y = merged['excess_return'].values\n            \n            # Remove NaN values\n            valid_mask = ~(np.isnan(X) | np.isnan(y))\n            X_clean = X[valid_mask]\n            y_clean = y[valid_mask]\n            \n            if len(X_clean) >= 10:\n                # Calculate beta (slope) and alpha (intercept)\n                beta = np.cov(X_clean, y_clean)[0, 1] / np.var(X_clean)\n                alpha = np.mean(y_clean) - beta * np.mean(X_clean)\n                \n                # Calculate R-squared\n                y_pred = alpha + beta * X_clean\n                ss_res = np.sum((y_clean - y_pred) ** 2)\n                ss_tot = np.sum((y_clean - np.mean(y_clean)) ** 2)\n                r_squared = 1 - (ss_res / ss_tot) if ss_tot > 0 else 0\n                \n                metrics.update({\n                    'alpha_monthly': alpha,\n                    'alpha_annualized': alpha * 12,\n                    'beta': beta,\n                    'r_squared': r_squared\n                })\n                \n                # Calculate alpha t-statistic\n                residuals = y_clean - y_pred\n                alpha_std_error = np.std(residuals, ddof=2) / np.sqrt(len(X_clean))\n                if alpha_std_error > 0:\n                    metrics['alpha_t_stat'] = alpha / alpha_std_error\n        \n        except (ValueError, ZeroDivisionError, np.linalg.LinAlgError):\n            logger.warning("Could not calculate CAPM metrics")\n        \n        # Information ratio\n        if 'market_ret' in merged.columns:\n            tracking_error = np.std(merged['portfolio_return'] - merged['market_ret'], ddof=1)\n            if tracking_error > 0:\n                active_return = np.mean(merged['portfolio_return'] - merged['market_ret'])\n                metrics['information_ratio'] = active_return / tracking_error\n        \n        return metrics\n    \n    def _calculate_drawdown_metrics(self, cumulative_returns: pd.Series) -> Dict:\n        """\n        Calculate drawdown metrics.\n        \n        Parameters:\n        -----------\n        cumulative_returns : pd.Series\n            Cumulative return series\n            \n        Returns:\n        --------\n        Dict\n            Drawdown metrics\n        """\n        # Calculate running maximum\n        running_max = cumulative_returns.expanding().max()\n        \n        # Calculate drawdowns\n        drawdowns = (cumulative_returns - running_max) / running_max\n        \n        return {\n            'max_drawdown': drawdowns.min(),\n            'avg_drawdown': drawdowns[drawdowns < 0].mean() if (drawdowns < 0).any() else 0,\n            'drawdown_periods': (drawdowns < -0.05).sum()  # Periods with >5% drawdown\n        }\n    \n    def _calculate_skewness(self, returns: np.ndarray) -> float:\n        """\n        Calculate skewness of returns.\n        """\n        if len(returns) < 3:\n            return np.nan\n        \n        mean_ret = np.mean(returns)\n        std_ret = np.std(returns, ddof=1)\n        \n        if std_ret == 0:\n            return np.nan\n        \n        n = len(returns)\n        skew = (n / ((n-1) * (n-2))) * np.sum(((returns - mean_ret) / std_ret) ** 3)\n        \n        return skew\n    \n    def _calculate_kurtosis(self, returns: np.ndarray) -> float:\n        """\n        Calculate excess kurtosis of returns.\n        """\n        if len(returns) < 4:\n            return np.nan\n        \n        mean_ret = np.mean(returns)\n        std_ret = np.std(returns, ddof=1)\n        \n        if std_ret == 0:\n            return np.nan\n        \n        n = len(returns)\n        kurt = (n * (n+1) / ((n-1) * (n-2) * (n-3))) * np.sum(((returns - mean_ret) / std_ret) ** 4)\n        kurt -= 3 * (n-1)**2 / ((n-2) * (n-3))  # Excess kurtosis\n        \n        return kurt\n    \n    def calculate_portfolio_statistics_table(self, \n                                           portfolio_returns: pd.DataFrame) -> pd.DataFrame:\n        """\n        Create a summary statistics table for portfolios.\n        \n        Parameters:\n        -----------\n        portfolio_returns : pd.DataFrame\n            Portfolio returns data\n            \n        Returns:\n        --------\n        pd.DataFrame\n            Summary statistics table\n        """\n        if portfolio_returns.empty:\n            return pd.DataFrame()\n        \n        performance_metrics = self.calculate_performance_metrics(portfolio_returns)\n        \n        # Create table\n        table_data = []\n        \n        for portfolio_key, metrics in performance_metrics.items():\n            if 'portfolio_' in portfolio_key:\n                portfolio_num = int(portfolio_key.split('_')[1])\n                \n                row = {\n                    'Portfolio': portfolio_num,\n                    'Mean Return (%)': metrics.get('mean_return', np.nan) * 100,\n                    'Std Dev (%)': metrics.get('std_return', np.nan) * 100,\n                    'Annualized Return (%)': metrics.get('annualized_return', np.nan) * 100,\n                    'Annualized Vol (%)': metrics.get('annualized_volatility', np.nan) * 100,\n                    'Sharpe Ratio': metrics.get('sharpe_ratio', np.nan),\n                    'Max Drawdown (%)': metrics.get('max_drawdown', np.nan) * 100,\n                    'Observations': metrics.get('observations', 0)\n                }\n                \n                if 'alpha_annualized' in metrics:\n                    row['Alpha (%)'] = metrics['alpha_annualized'] * 100\n                    row['Beta'] = metrics.get('beta', np.nan)\n                \n                table_data.append(row)\n        \n        # Add long-short row if available\n        if 'long_short' in performance_metrics:\n            ls_metrics = performance_metrics['long_short']\n            row = {\n                'Portfolio': 'Long-Short',\n                'Mean Return (%)': ls_metrics.get('mean_return', np.nan) * 100,\n                'Std Dev (%)': ls_metrics.get('std_return', np.nan) * 100,\n                'Annualized Return (%)': ls_metrics.get('annualized_return', np.nan) * 100,\n                'Annualized Vol (%)': ls_metrics.get('annualized_volatility', np.nan) * 100,\n                'Sharpe Ratio': ls_metrics.get('sharpe_ratio', np.nan),\n                'Max Drawdown (%)': np.nan,\n                'Observations': ls_metrics.get('observations', 0)\n            }\n            table_data.append(row)\n        \n        return pd.DataFrame(table_data)\n    \n    def _get_stock_id_column(self, data: pd.DataFrame) -> str:\n        """Get the stock identifier column name."""\n        if 'permno' in data.columns:\n            return 'permno'\n        elif 'ticker' in data.columns:\n            return 'ticker'\n        else:\n            raise ValueError("No stock identifier column found (permno or ticker)")\n\ndef main():\n    """Example usage of ReturnsCalculator."""\n    # This would typically be called from the main strategy class\n    # See momentum_strategy.py for complete integration\n    pass\n\nif __name__ == "__main__":\n    main()